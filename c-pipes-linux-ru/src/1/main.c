#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>
#include <sys/types.h>
#include <signal.h>
/**
 * Конвеер из двух фильтров, задание:
 * 1-й фильтр разбивает текст на страницы по 24 строки и нумерует их
 * (вставляет в начало каждой страницы строку PAGE N, где N - номер страницы)
 * 2-й фильтр удаляет пробелы с начала строки.
 *
 * Компиляция программы:
 * $ gcc -o main main.c
 * или:
 * $ make
 *
 * Проверка работы программы:
 * $ cat файл | ./main
 *
 * файл - любой не пустой текстовый файл
 */
int main() {
    // код процесса-отца
    // переменные для хранения PID дочерних процессов
    int pid_first, pid_second;
    // переменные используются для анализа кода завершения дочерних
    // процессов
    int status, result;
    // инициализация канала связи
    int fd[2];
    if(pipe(fd) == -1) {
        // если произошла ошибка
        printf("Невозможно создать канал связи.\n");
        // завершаем работу программы
        exit(EXIT_FAILURE);
    }
    // создание первого дочернего процесса
    if((pid_first = fork()) == 0) {
        // код первого дочернего процесса
        // (1-й фильтр)
        // перенаправление потока вывода на канал связи
        // процесс будет читать данные с stdin
        // писать данные в fd[1]
        close(1); dup(fd[1]); close(fd[1]); close(fd[0]);
        // запуск команды awk, которая разбивает текст на страницы:
        // awk BEGIN{f=-1}{f++}{if(!(f%24)) print "PAGE "f/24+1; print $0}
        // (следует убедиться, что awk действительно располагается в папке /usr/bin
        // возможно понадобится изменить путь /usr/bin/awk)
        execl("/usr/bin/awk", "awk","BEGIN{f=-1}{f++}{if(!(f%24)) print \"PAGE \"f/24+1; print $0}", 0);
        // в случае неудачного исполнения команды awk
        printf("Первый фильтр отработал с ошибкой.\n");
        exit(EXIT_FAILURE);
    } else if(pid_first == -1) {
        // код процесса-отца
        // если не удалось запустить дочерний процесс
        printf("Неудалось создать первый дочерний процесс.\n");
        // завершаем работу программы
        exit(EXIT_FAILURE);
    }
    // создание второго дочернего процесса
    if((pid_second = fork()) == 0) {
        // код второго дочернего процесса
        // (2-й фильтр)
        // перенаправления потока ввода на канал связи
        // процесс будет читать данные с fd[0]
        // писать данные в stdout
        close(0); dup(fd[0]); close(fd[0]); close(fd[1]);
        // запуск команды sed, которая удаляет лишние пробелы с начала строки
        // (следует убедиться, что sed действительно располагается в папке /bin
        // возможно понадобится изменить путь /bin/sed)
        execl("/bin/sed", "sed", "s/^ \\{1,\\}//g", 0);
        // в случае неудачного исполнения команды sed
        printf("Ошибка вызова второго фильтра.\n");
        // завершаем работу процесса
        exit(EXIT_FAILURE);
    } else if(pid_second == -1) {
        // код процесса-отца
        // если не удалось запустить дочерний процесс
        printf("Неудалось создать второй дочерний процесс.\n");
        // посылаем сигнал SIGKILL (завершения) первому дочернему процессу
        kill(pid_first, SIGKILL);
        // завершаем работу программы
        exit(EXIT_FAILURE);
    }
    // закрываем неиспользуемые дескрипторы каналов связи
    close(fd[0]); close(fd[1]);
    // ожидание завершения дочерних процессов
    wait(&status);
    result = status;
    wait(&status);
    result |= status;
    // проверка кода возврата дочерних процессов
    if(result != 0) {
        exit(EXIT_FAILURE);
    } else {
        exit(EXIT_SUCCESS);
    }
}
