#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
// дескриптор канала чтения в массивах
#define R  0
// дескриптор канала записи в массивах
#define W 1
// максимальный размер буфера для чтения/записи данных
#define BUFFER_SIZE 1024
/**
 * Взаимодействие процессов через неименованный канал.
 *
 * Этот процесс:
 * 1-й фильтр разбивает текст на страницы по 24 строки и нумерует их
 * (вставляет в начало каждой страницы строку PAGE N, где N - номер страницы)
 *
 * Компиляция программы:
 * $ gcc -o skipspaces skipspaces.c
 * $ gcc -o main main.c
 * или
 * $ make
 *
 * Проверка работы программы:
 * cat файл | ./main
 *
 * файл - любой текстовый файл
 */
int main() {
    // массив первого канал связи (от главного к дочернему)
    int MAIN_CHILD[2];
    // массив второго канала связи (от дочернего к главному)
    int CHILD_MAIN[2];
    // PID дочернего процесса
    int pid;
    // попытка открыть первый канал связи
    if(pipe(MAIN_CHILD) == -1) {
        // в случае ошибки
        printf("Невозможно создать первый канал связи.\n");
        // завершение работы программы
        exit(EXIT_FAILURE);
    }
    // попытка открыть второй канал связи
    if(pipe(CHILD_MAIN) == -1) {
        // в случае ошибки
        printf("Невозможно создать канал связи.\n");
        // завершение работы программы
        exit(EXIT_FAILURE);
    }
    // создание дочернего процесса
    if((pid = fork()) == 0) {
        // дочерний процесс - запускает программу второго фильтра
        // закрываем неиспользуемые дескрипторы
        close(MAIN_CHILD[W]);
        close(CHILD_MAIN[R]);
        // читаем данные с канала от главного к дочернему
        close(R); dup(MAIN_CHILD[R]); close(MAIN_CHILD[R]);
        // пишем данные в канал от дочернего к главному
        close(W); dup(CHILD_MAIN[W]); close(CHILD_MAIN[W]);
        // запускаем второй фильтр
        execl("skipspaces", "skipspaces", 0);
        // если программа второго фильтра завершилась с ошибкой
        printf("Ошибка выполнения второго фильтра.\n");
        // полность закрываем каналы
        close(MAIN_CHILD[R]);
        close(CHILD_MAIN[W]);
        // процесс завершает выполнение с ошибкой
        exit(EXIT_FAILURE);
    } else if(pid == -1) {
        // если дочерний процесс не был создан
        printf("Неудалось создать дочерний процесс.");
        // завершение работы программы
        exit(EXIT_FAILURE);
    }
    // процесс-отец
    // закрываем неиспользуемые дескрипторы
    close(MAIN_CHILD[R]);
    close(CHILD_MAIN[W]);
    // буфер для чтения строк из входного потока
    char buffer[BUFFER_SIZE];
    // буфер для записи номера страницы
    char page_str[BUFFER_SIZE];
    // текущий номер строки
    int num = 0;
    // читаем данные из входного потока
    while(fgets(buffer, BUFFER_SIZE, stdin)) {
        // если строка делится на 24 без остатка
        if(num % 24 == 0) {
            // вставляем номер страницы
            sprintf(page_str, "PAGE %d\n", num / 24 + 1);
            write(MAIN_CHILD[W], page_str, (strlen(page_str) * sizeof(char)));
        }
        // вывод строки
        write(MAIN_CHILD[W], buffer, (strlen(buffer)) * sizeof(char));
        num++;
    }
    // полностью закрываем канал от отца к дочернему процессу
    close(MAIN_CHILD[W]);
    // читаем данные из канала от дочернего процессу отцу построчно
    close(R); dup(CHILD_MAIN[R]); close(CHILD_MAIN[R]);
    while(fgets(buffer, BUFFER_SIZE, stdin)) {
        // выводим прочитанные данные на экран
        printf("%s", buffer);
    }
    // полностью закрываем канал от дочернего к отцу
    close(CHILD_MAIN[R]);
}
