#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>
// максимальный размер буфера чтения/записи
#define BUFFER_SIZE 1024
// общий заголовочный файл для клиента и сервера
#include "public.h"
/**
 * Программа-клиент:
 * 1. Создаёт личный именованный канал.
 * 2. Передаёт его имя через общий канал программе-серверу.
 * 3. Читает строки из личного именованного канала.
 * 4. Выводит на экран строки, пропустив пробелы в их начале.
 * 5. Удаляет файл личного именованного канала.
 *
 * ПОДРОБНЕЕ - КОМПИЛЯЦИЯ И ЗАПУСК - в файле server.h !!!!!!!!!!!!!!!!!!!!!!!!!!!
 */
int main() {
    // создаём объект сообщения
    message message;
    // записываем в него имя личного именованного канала
    sprintf(message.file_name, "/tmp/%d", getpid());
    // попытка создать приватный именованный канал
    if(mkfifo(message.file_name, 0666) == -1) {
        // если не удалось - завершаем работа
        printf("Невозможно создать приватный канал.\n");
        exit(EXIT_FAILURE);
    }
    // открываем общий канал для записи
    int out;
    if((out = open(PUBLIC, O_WRONLY)) == -1) {
        // если не удалось - завершаем работу
        printf("Ошибка открытия общего канала.\n");
        exit(EXIT_FAILURE);
    }
    // пишем в общий канал имя файла личного канала
    write(out, &message, sizeof(message));
    // закрываем общий канал для записи
    close(out);
    // открываем приватный канал для чтения
    int in;
    if((in = open(message.file_name, O_RDONLY)) == -1) {
        // если не удалось
        printf("Ошибка открытия приватного канала для чтения.\n");
        exit(EXIT_FAILURE);
    }
    // итератор для строки
    int i = 0;
    // флаг будет установлен, когда станет достигнут конец общего канала
    int eof = 0;
    // буфер для чтения строки
    char buffer[BUFFER_SIZE];
    // построчное чтение данных из общего канала, пока не достигнут его конец
    while(!eof) {
        i =  -1;
        do {
            i++;
            // читаем один символ в buffer[i]
            if(read(in, buffer + i, sizeof(char)) < 1 ) {
                // если прочитать неудалось - достигнут конец канала
                eof = 1;
            }
        // пока не достигнут конец строки или конец канала
        } while(buffer[i] != '\n' && buffer != '\0' && !eof);
        // если достигнут конец канала
        if(eof) {
            buffer[i] = '\0';
        // если достигнут конец строки
        } else {
            buffer[i + 1] = '\0';
        }
        i = 0;
        while(buffer[i] == ' ' && buffer[i] != '\n' && buffer[i] != '\0')
            i++;
        // выводим строку на экран
        printf("%s", buffer + i);
    }
    // закрываем общий канал для чтения
    close(in);
    // удаляем файл, который является личным именованным каналом
    if(unlink(message.file_name) == -1) {
        printf("Невозможно удалить файл приватного канала.\n");
    }
}
